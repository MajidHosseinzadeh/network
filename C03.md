# 1-20

## ۱. هدف اصلی لایه انتقال (Transport Layer) چیست؟

**پاسخ:** هدف اصلی فراهم کردن **ارتباط منطقی (Logical Communication)** بین فرآیندهای کاربردی (Application Processes) است که بر روی میزبان‌های (Hosts) مختلف در حال اجرا هستند.

## ۲. تفاوت اصلی بین سرویس‌های لایه انتقال و لایه شبکه چیست؟

**پاسخ:**

- **لایه شبکه (Network Layer):** ارتباط منطقی بین **میزبان‌ها (Hosts)** را فراهم می‌کند.
- **لایه انتقال (Transport Layer):** ارتباط منطقی بین **فرآیندها (Processes)** را فراهم می‌کند و بر سرویس‌های لایه شبکه تکیه دارد و آنها را بهبود می‌بخشد.

## ۳. در "تشبیه خانواده" (Household Analogy) برای توضیح لایه انتقال، هر کدام از اجزا معادل چه چیزی در شبکه هستند؟

**پاسخ:**

- **بچه‌ها:** معادل فرآیندها (Processes).
- **خانه‌ها:** معادل میزبان‌ها (Hosts).
- **نامه‌ها:** معادل پیام‌های لایه کاربرد.
- **آن و بیل (کسانی که نامه‌ها را جمع‌آوری/توزیع می‌کنند):** معادل پروتکل لایه انتقال.
- **سرویس پست:** معادل پروتکل لایه شبکه.

## ۴. وظایف پروتکل لایه انتقال در سمت فرستنده (Sender) چیست؟

**پاسخ:** پیام‌های لایه کاربرد را دریافت می‌کند، آنها را به قطعات کوچک‌تر به نام **سگمنت (Segment)** می‌شکند، فیلدهای هدر (Header) مناسب را اضافه می‌کند و سپس سگمنت را به لایه شبکه (IP) تحویل می‌دهد.

## ۵. وظایف پروتکل لایه انتقال در سمت گیرنده (Receiver) چیست؟

**پاسخ:** سگمنت‌ها را از لایه شبکه (IP) دریافت می‌کند، هدر آن‌ها را بررسی می‌کند، پیام لایه کاربرد را استخراج کرده و از طریق **دی‌مالتی‌پلکسینگ (Demultiplexing)** پیام را به سوکت برنامه صحیح تحویل می‌دهد.

## ۶. دو پروتکل اصلی لایه انتقال در اینترنت کدامند و چه ویژگی‌های کلی دارند؟

**پاسخ:**

1. **TCP (Transmission Control Protocol):** ارائه انتقال مطمئن (Reliable) و به ترتیب، کنترل ازدحام، کنترل جریان و ایجاد اتصال (Connection-oriented).
2. **UDP (User Datagram Protocol):** انتقال نامطمئن (Unreliable) و بدون ترتیب، "بهترین تلاش" (Best-effort)، بدون ایجاد اتصال (Connectionless) و ساده.

## ۷. چه سرویس‌هایی توسط پروتکل‌های لایه انتقال اینترنت ارائه نمی‌شوند؟

**پاسخ:** تضمین تاخیر (Delay Guarantees) و تضمین پهنای باند (Bandwidth Guarantees).

## ۸. منظور از مالتی‌پلکسینگ (Multiplexing) در سمت فرستنده چیست؟

**پاسخ:** جمع‌آوری داده‌ها از چندین سوکت مختلف، افزودن هدر لایه انتقال به آن‌ها (برای استفاده در دی‌مالتی‌پلکسینگ بعدی) و ارسال آن‌ها به لایه شبکه.

## ۹. منظور از دی‌مالتی‌پلکسینگ (Demultiplexing) در سمت گیرنده چیست؟

**پاسخ:** استفاده از اطلاعات موجود در هدر سگمنت (مانند شماره پورت) برای تحویل سگمنت‌های دریافت شده به سوکت صحیح.

## ۱۰. میزبان (Host) چگونه متوجه می‌شود که یک سگمنت دریافتی را به کدام سوکت تحویل دهد؟

**پاسخ:** میزبان با استفاده از **آدرس‌های IP** (در دیتاگرام لایه شبکه) و **شماره پورت‌های مبدا و مقصد** (در سگمنت لایه انتقال)، سگمنت را به سوکت مناسب هدایت می‌کند. هر سگمنت TCP/UDP دارای فیلد ۳۲ بیتی شامل پورت مبدا و پورت مقصد است.

# 21-40

## ۱. در دی‌مالتی‌پلکسینگ بدون اتصال (UDP)، گیرنده چگونه سگمنت مناسب را شناسایی می‌کند؟

**پاسخ:** گیرنده فقط **شماره پورت مقصد** را بررسی می‌کند. اگر دو سگمنت UDP دارای پورت مبدا یا آدرس IP مبدا متفاوت باشند اما پورت مقصدشان یکسان باشد، هر دو به **یک سوکت** و فرآیند واحد در مقصد هدایت می‌شوند.

## ۲. یک سوکت اتصال‌گرا (TCP) با چه اطلاعاتی شناسایی می‌شود؟

**پاسخ:** با یک **۴-تایی (4-tuple)** شامل:

1. آدرس IP مبدا
2. شماره پورت مبدا
3. آدرس IP مقصد
4. شماره پورت مقصد

## ۳. تفاوت رفتار سرور در برخورد با درخواست‌های TCP و UDP از کلاینت‌های مختلف چیست؟

**پاسخ:**

- در **UDP**، کلاینت‌های مختلف که به یک پورت مقصد یکسان داده می‌فرستند، همگی وارد یک سوکت واحد در سرور می‌شوند.
- در **TCP**، سرور برای هر کلاینت (با IP و پورت مبدا متفاوت)، یک **سوکت اختصاصی جدید** ایجاد می‌کند. بنابراین سرور می‌تواند همزمان چندین سوکت TCP با شناسه ۴-تایی متفاوت داشته باشد.

## ۴. ویژگی‌های اصلی پروتکل UDP چیست؟

**پاسخ:**

- **بدون اتصال (Connectionless):** هیچ دست‌تکانی (Handshaking) بین فرستنده و گیرنده انجام نمی‌شود (بنابراین تاخیر RTT اولیه ندارد).
- **بهترین تلاش (Best Effort):** سگمنت‌ها ممکن است گم شوند یا با ترتیب اشتباه برسند.
- **ساده:** هدر کوچکی دارد و وضعیت اتصال (State) را نگه نمی‌دارد.
- **بدون کنترل ازدحام:** می‌تواند با هر سرعتی که بخواهد داده ارسال کند.

## ۵. ساختار هدر (Header) سگمنت UDP شامل چه فیلدهایی است؟

**پاسخ:** هدر UDP بسیار ساده و ۸ بایتی است و شامل ۴ فیلد (هر کدام ۱۶ بیت) می‌باشد:

1. پورت مبدا (Source Port)
2. پورت مقصد (Dest Port)
3. طول (Length)
4. چک‌سام (Checksum)

## ۶. چرا برخی برنامه‌ها (مانند استریم مالتی‌مدیا یا DNS) پروتکل UDP را ترجیح می‌دهند؟

**پاسخ:**

- تحمل از دست رفتن داده را دارند اما به سرعت حساس هستند.
- نمی‌خواهند درگیر تاخیر ایجاد اتصال شوند.
- می‌خواهند کنترل دقیقی روی زمان و نرخ ارسال داده داشته باشند و محدود به کنترل ازدحام TCP نشوند.

## ۷. هدف از فیلد Checksum در UDP چیست و چگونه کار می‌کند؟

**پاسخ:** هدف، تشخیص خطا (مانند تغییر بیت‌ها یا Flipped bits) در سگمنت ارسال شده است. فرستنده محتوای سگمنت را به صورت اعداد ۱۶ بیتی در نظر می‌گیرد و جمع مکمل یک (One's complement sum) آن‌ها را محاسبه کرده و در فیلد چک‌سام قرار می‌دهد. گیرنده مجدداً محاسبه می‌کند و اگر نتیجه مغایرت داشت، خطا تشخیص داده می‌شود.

## ۸. آیا چک‌سام UDP محافظت کامل در برابر خطا را تضمین می‌کند؟

**پاسخ:** خیر، محافظت ضعیفی ارائه می‌دهد. ممکن است دو بیت مختلف طوری تغییر کنند که مجموع آنها تغییری نکند و خطا تشخیص داده نشود.

## ۹. اگر برنامه‌ای نیاز به انتقال مطمئن (Reliable Transfer) داشته باشد اما بخواهد از UDP استفاده کند، چه باید کرد؟

**پاسخ:** باید مکانیزم‌های قابلیت اطمینان (مانند تایید دریافت و ارسال مجدد) و کنترل ازدحام را در **لایه کاربرد (Application Layer)** پیاده‌سازی کند (مانند کاری که در HTTP/3 و QUIC انجام شده است).

## ۱۰. مفهوم انتزاعی "انتقال داده مطمئن" (Reliable Data Transfer - rdt) چیست؟

**پاسخ:** ایجاد توهم وجود یک کانال مطمئن برای لایه بالا (کاربرد)، در حالی که کانال زیرین (لایه فیزیکی یا شبکه) غیرقابل اعتماد است و ممکن است داده‌ها را گم کند، خراب کند یا ترتیب آنها را به هم بزند.

# 41-60

## ۱. چهار فراخوانی اصلی تابع (Function Call) در رابط‌های پروتکل انتقال داده مطمئن (rdt) کدامند؟

**پاسخ:**

1. `rdt_send()`: توسط لایه بالا (کاربرد) برای ارسال داده صدا زده می‌شود.
2. `udt_send()`: توسط پروتکل rdt برای ارسال بسته روی کانال نامطمئن صدا زده می‌شود.
3. `rdt_rcv()`: زمانی که بسته‌ای از طرف گیرنده دریافت می‌شود، صدا زده می‌شود.
4. `deliver_data()`: توسط rdt برای تحویل داده‌های سالم به لایه بالا صدا زده می‌شود.

## ۲. برای مشخص کردن رفتار فرستنده و گیرنده در پروتکل‌های rdt از چه ابزاری استفاده می‌شود؟

**پاسخ:** از **ماشین‌های حالت محدود (Finite State Machines - FSM)** استفاده می‌شود که وضعیت‌ها، رویدادهای گذار و اقدامات انجام شده را نشان می‌دهند.

## ۳. پروتکل rdt2.0 برای مقابله با "خطای بیت" (Bit Errors) از چه مکانیزم‌هایی استفاده می‌کند؟

**پاسخ:**

- **Checksum:** برای تشخیص خطا در بسته.
- **ACK (تایید مثبت):** گیرنده به فرستنده می‌گوید بسته سالم رسیده است.
- **NAK (تایید منفی):** گیرنده به فرستنده می‌گوید بسته خراب بوده است.
- **Retransmission:** فرستنده در صورت دریافت NAK، بسته را دوباره ارسال می‌کند.

## ۴. پروتکل "توقف و انتظار" (Stop-and-wait) چیست؟

**پاسخ:** پروتکلی است که در آن فرستنده یک بسته را ارسال می‌کند و تا زمانی که پاسخ قطعی (ACK یا NAK) از گیرنده دریافت نکند، بسته بعدی را ارسال نمی‌کند. (مانند rdt2.0).

## ۵. نقص "مرگبار" (Fatal Flaw) در پروتکل rdt2.0 چیست؟

**پاسخ:** اگر بسته **ACK یا NAK در مسیر خراب شود** (Corrupted)، فرستنده نمی‌داند که گیرنده بسته را درست دریافت کرده است یا خیر. اگر فرستنده صرفاً بسته را دوباره بفرستد، گیرنده نمی‌داند این بسته جدید است یا تکرار بسته قبلی (Duplicate).

## ۶. پروتکل rdt2.1 چگونه مشکل خرابی ACK/NAK را حل می‌کند؟

**پاسخ:** با افزودن **شماره توالی (Sequence Number)** به بسته‌ها. اگر گیرنده بسته‌ای با شماره تکراری دریافت کند، می‌فهمد که ACK قبلی گم شده یا خراب شده است و بسته تکراری را دور می‌ریزد (Discard)، اما دوباره ACK می‌فرستد.

## ۷. چرا در پروتکل‌های Stop-and-wait (مانند rdt2.1) تنها دو شماره توالی (۰ و ۱) کافی است؟

**پاسخ:** زیرا در هر لحظه تنها یک بسته تایید نشده می‌تواند در حال پرواز (In-flight) باشد. بنابراین فرستنده و گیرنده فقط باید بتوانند بین "بسته فعلی" و "بسته قبلی/بعدی" تمایز قائل شوند.

## ۸. پروتکل rdt2.2 چگونه بدون استفاده از NAK (NAK-free) عمل می‌کند؟

**پاسخ:** به جای ارسال NAK برای بسته خراب، گیرنده برای **آخرین بسته‌ای که سالم دریافت کرده است**، یک ACK می‌فرستد و شماره توالی آن را در ACK ذکر می‌کند. دریافت دو ACK یکسان (Duplicate ACK) توسط فرستنده، به معنی NAK برای بسته بعدی است.

## ۹. فرضیه جدید در پروتکل rdt3.0 نسبت به نسخه‌های قبلی چیست و چه چالشی ایجاد می‌کند؟

**پاسخ:** فرض می‌شود که کانال زیرین علاوه بر تغییر بیت، ممکن است بسته‌ها (داده یا ACK) را **گم کند (Lose)**. چالش این است که فرستنده نمی‌داند آیا بسته گم شده، یا ACK گم شده، یا صرفاً تاخیر شبکه زیاد است.

## ۱۰. مکانیزم اصلی در rdt3.0 برای مدیریت بسته‌های گم شده چیست؟

**پاسخ:** استفاده از **تایمر شمارش معکوس (Countdown Timer)**. فرستنده پس از ارسال بسته، مدت زمان "معقولی" منتظر می‌ماند. اگر در این مدت ACK دریافت نشد (Timeout)، فرض می‌کند بسته گم شده و آن را دوباره ارسال می‌کند (Retransmit).

# 61-80

## ۱. در پروتکل rdt3.0، فرستنده در صورت وقوع Timeout چه واکنشی نشان می‌دهد؟

**پاسخ:** فرستنده فرض می‌کند بسته گم شده است، بنابراین بسته فعلی را **مجدداً ارسال (Retransmit)** می‌کند و تایمر را دوباره شروع می‌کند.

## ۲. مشکل اصلی کارایی (Performance) در پروتکل rdt3.0 (توقف و انتظار) چیست؟

**پاسخ:** بهره‌وری (Utilization) لینک بسیار پایین است. فرستنده بیشتر زمان خود را صرف انتظار برای دریافت ACK می‌کند و از ظرفیت پهنای باند لینک برای ارسال داده استفاده نمی‌کند (به‌ویژه در لینک‌های با سرعت بالا و تاخیر زیاد).

## ۳. تکنیک "لوله‌گذاری" (Pipelining) چگونه مشکل کارایی پروتکل‌های توقف-و-انتظار را حل می‌کند؟

**پاسخ:** این تکنیک به فرستنده اجازه می‌دهد تا چندین بسته را پشت سر هم ارسال کند بدون اینکه منتظر دریافت ACK تک‌تک آن‌ها بماند (چندین بسته "در پرواز" یا in-flight مجاز هستند). این کار بهره‌وری لینک را به طور چشمگیری افزایش می‌دهد.

## ۴. در پروتکل "بازگشت به N" (Go-Back-N)، منظور از "ACK تجمعی" (Cumulative ACK) چیست؟

**پاسخ:** دریافت `ACK(n)` به این معنی است که تمام بسته‌ها با شماره توالی **تا و شامل n** به درستی دریافت شده‌اند.

## ۵. در پروتکل Go-Back-N، اگر تایمر برای بسته n منقضی شود، فرستنده چه می‌کند؟

**پاسخ:** فرستنده بسته n و **تمام بسته‌های بعدی** که ارسال شده‌اند اما هنوز ACK نشده‌اند (یعنی تمام بسته‌های موجود در پنجره ارسال) را مجدداً ارسال می‌کند.

## ۶. گیرنده در پروتکل Go-Back-N با بسته‌های "خارج از ترتیب" (Out-of-order) چه می‌کند؟

**پاسخ:** گیرنده معمولاً آن‌ها را **دور می‌ریزد (Discard)** و بافر نمی‌کند. سپس یک ACK برای آخرین بسته‌ای که به صورت مرتب (In-order) دریافت کرده است، دوباره ارسال می‌کند.

## ۷. تفاوت اصلی استراتژی ارسال مجدد در "تکرار انتخابی" (Selective Repeat) با Go-Back-N چیست؟

**پاسخ:** در تکرار انتخابی، فرستنده تنها بسته‌ای را که مشکوک به گم شدن یا خرابی است (تایمر آن منقضی شده) مجدداً ارسال می‌کند و کاری به بسته‌های بعدی که ACK شده‌اند ندارد.

## ۸. گیرنده در پروتکل "تکرار انتخابی" (SR) با بسته‌های خارج از ترتیب چه می‌کند؟

**پاسخ:** گیرنده این بسته‌ها را **بافر (Buffer)** می‌کند تا زمانی که بسته‌های گم‌شده قبلی برسند و بتواند آن‌ها را به ترتیب صحیح به لایه بالاتر تحویل دهد.

## ۹. "معضل پنجره" (Window Dilemma) در پروتکل تکرار انتخابی چیست؟

**پاسخ:** اگر اندازه پنجره (Window Size) نسبت به فضای شماره توالی (Sequence Number Space) خیلی بزرگ باشد، گیرنده ممکن است نتواند تشخیص دهد که بسته دریافتی یک بسته جدید است یا ارسال مجدد بسته‌ای از پنجره قبلی. برای جلوگیری از این مشکل، اندازه پنجره باید کمتر یا مساوی نصف فضای شماره توالی باشد.

## ۱۰. ویژگی‌های کلیدی پروتکل TCP (بر اساس دیدگاه کلی) چیست؟

**پاسخ:**

- ارتباط نقطه-به-نقطه (Point-to-point).
- جریان بایت مطمئن و مرتب (Reliable, in-order byte stream).
- اتصال‌گرا (Connection-oriented) با استفاده از دست‌تکانی.
- استفاده از ACKهای تجمعی و لوله‌گذاری.
- دارای کنترل جریان (Flow Control) و کنترل ازدحام (Congestion Control).
